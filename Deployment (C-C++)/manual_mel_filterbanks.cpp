#include <arm_math.h>
#include <math.h>
#include "manual_Mel_filterbanks.h"
#include "filterbanks.h"


const int frame_length = (int)(kFeatureSliceDurationMs * (kAudioSampleFrequency/1000));  // 400
    // note that the matrix generated by the python script
    // determines the max, min frequancy captured by the filters. 
// const float fmin = 80.0f;
// const float fmax = 2500.0f;


// === STATIC BUFFERS  ===
static float hann_window[frame_length];
static float __attribute__((aligned(16))) fft_input[kMaxAudioSampleSize];
static float __attribute__((aligned(16))) fft_output[kMaxAudioSampleSize]; // Holds complex FFT: real+imag
static bool is_initialized = false;

// === FILTERS MATRIX ===
// this is now in the filterbanks.h/cpp

// === FFT ARM OBJECT  ===
static arm_rfft_fast_instance_f32 fft_instance;

// === Utility: Hann window init ===
void InitializeHannWindow() {
    for (int i = 0; i < frame_length; i++) {
        hann_window[i] = 0.5f * (1.0f - cosf(2.0f * PI * i / (frame_length - 1)));
    }}


// // === for testing perpouses ===
// #include "slice1.h"
// float test_input[400];
// // === load 1st slice === /only for testing
// void LoadTestSlice() {
//     memcpy(test_input, slice1_bin, 400 * sizeof(float));
// }

// === Main Function: Compute log-mel slice ===
bool ComputeLogMelSlice(const int16_t* input, float* output) {
    if (!is_initialized) {
        InitializeHannWindow();
        arm_rfft_fast_init_f32(&fft_instance, kMaxAudioSampleSize);
        is_initialized = true;
    }

    // Apply window and zero pad ---
    // note: turn to float32 (easier) -> normalize (librosa load output)
    for (int i = 0; i < frame_length; i++) {
        // Convert to [-1, 1] | match training
        float normalized = (float)(input[i]) / 32768.0f;
        fft_input[i] = normalized * hann_window[i];
    }
    for (int i = frame_length; i < kMaxAudioSampleSize; i++) {
        fft_input[i] = 0.0f;
    }

    // Perform FFT ===
    arm_rfft_fast_f32(&fft_instance, fft_input, fft_output, 0);

    // Compute power spectrum ---
    // re-use the FFT_input, saving ~1.01KB
    float* power_spectrum = fft_input;  
    power_spectrum[0] = fft_output[0] * fft_output[0]; // DC
    power_spectrum[kFTTBins - 1] = fft_output[1] * fft_output[1]; // Nyquist
    
    const float* p = &fft_output[2]; // Start from bin 1
    for (int i = 1; i < kFTTBins - 1; i++, p += 2) {
        power_spectrum[i] = p[0] * p[0] + p[1] * p[1]; // a + ib
    }
    // Apply mel filterbank ---
    for (int i = 0; i < kFeatureSliceSize; i++) {
        arm_dot_prod_f32(filterbanks[i], power_spectrum, kFTTBins, &output[i]);
    }


    // Log scale ---
    for (int i = 0; i < kFeatureSliceSize; i++) {
        output[i] = logf(output[i] + 1e-6f);
    }

    // unfourtinatly I can't do the vectorized version since the loop of adding 1e-6
    // acctualy ends out to be more time consuming than the non-vectorized implementation
    // around ~0.4ms slowerd... however the logf is compiler optimized so we're good...
    // for (int i = 0; i < num_mel_bins; i++) {
        // output[i] += 1e-6f; 
    // }
    // arm_vlog_f32(output, output, num_mel_bins);


    return true;
}
