#include <arm_math.h>
#include <math.h>
#include "filterbanks.h"


// === HYPERPARAMETERS ===
const int sample_rate = 16000;
const float window_duration_sec = 0.025f;
const float window_stride_sec = 0.015f;
const int fft_length = 512;

    // note that the matrix generated by the python script
    // determines the max, min frequancy captured by the filters. 
// const float fmin = (None);
// const float fmax = (None); | so to change these, just change the python implementation

const int frame_length = (int)(window_duration_sec * sample_rate);  // 400
const int frame_step = (int)(window_stride_sec * sample_rate);      // 240

// === STATIC BUFFERS  ===
static float hann_window[frame_length];
static float __attribute__((aligned(4))) fft_input[fft_length];
static float __attribute__((aligned(4))) fft_output[fft_length]; // Holds complex FFT: real+imag
static bool is_initialized = false;


// === FFT ARM OBJECT  ===
static arm_rfft_fast_instance_f32 fft_instance;

// === Utility: Hann window init ===
void InitializeHannWindow() {
    for (int i = 0; i < frame_length; i++) {
        hann_window[i] = 0.5f * (1.0f - cosf(2.0f * PI * i / (frame_length - 1)));
    }}


// === for testing perpouses ===
#include "slice1.h"
float test_input[400];
// === load 1st slice === /only for testing
void LoadTestSlice() {
    memcpy(test_input, slice1_bin, 400 * sizeof(float));
}

// === Main Function: Compute log-mel slice ===
bool ComputeLogMelSlice(const float* input, float* output) {
    if (!is_initialized) {
        InitializeHannWindow();
        arm_rfft_fast_init_f32(&fft_instance, fft_length);
        is_initialized = true;
    }

    // Apply window and zero pad ---
    // note: ya might wanna normalize if you're using this in the TFLM example
    for (int i = 0; i < frame_length; i++) {
        // float normalized = (float)(input[i]) / 32768.0f;
        fft_input[i] = input[i] * hann_window[i];
    }
    for (int i = frame_length; i < fft_length; i++) {
        fft_input[i] = 0.0f;
    }

    // Perform FFT ===
    arm_rfft_fast_f32(&fft_instance, fft_input, fft_output, 0);

    // Compute power spectrum ---
    // re-use the FFT_input, saving ~1.01KB
    float* power_spectrum = fft_input;  
    power_spectrum[0] = fft_output[0] * fft_output[0]; // DC
    power_spectrum[fft_bins - 1] = fft_output[1] * fft_output[1]; // Nyquist
    
    const float* p = &fft_output[2]; // Start from bin 1
    for (int i = 1; i < fft_bins - 1; i++, p += 2) {
        power_spectrum[i] = p[0] * p[0] + p[1] * p[1];
    }
    // Apply mel filterbank ---
    for (int i = 0; i < num_mel_bins; i++) {
        arm_dot_prod_f32(filterbanks[i], power_spectrum, fft_bins, &output[i]);
    }


    // Log scale ---
    for (int i = 0; i < num_mel_bins; i++) {
        output[i] = logf(output[i] + 1e-6f);
    }

    // unfourtinatly I can't do the vectorized version since the loop of adding 1e-6
    // acctualy ends out to be more time consuming than the non-vectorized implementation
    // around ~0.4ms slowerd... however the logf is compiler optimized so it's not that bad...
    // for (int i = 0; i < num_mel_bins; i++) {
        // output[i] += 1e-6f; 
    // }
    // arm_vlog_f32(output, output, num_mel_bins);


    return true;
}



void setup() {
    Serial.begin(115200);
    while(!Serial);

    LoadTestSlice();
    Serial.print("Audio input:");
    for(int i=0; i<400; i++){
        Serial.print(test_input[i], 6);
        Serial.print(" ");
    }
    delay(10);

    float mel_output[num_mel_bins];

    long t = micros(); //to get time of function of one slice
    ComputeLogMelSlice(test_input, mel_output);
    t = micros() - t;

    Serial.println("Mel energies:");
    for (int i = 0; i < num_mel_bins; i++) {
        Serial.print(mel_output[i], 2);
        Serial.print(" ");
    }
    Serial.println();
    Serial.print("Took: ");
    Serial.print(t);
    Serial.print("microseconds.");

    
}

void loop() {}




bool ComputeLogMelSlice(const float* input, float* output) {
    if (!is_initialized) {
        InitializeHannWindow();
        fft_cfg = kiss_fftr_alloc(fft_length, 0, NULL, NULL);
        is_initialized = true;
    }

    // Apply window & zero pad
    for (int i = 0; i < frame_length; i++) {
        fft_input[i] = input[i] * hann_window[i];
    }
    for (int i = frame_length; i < fft_length; i++) {
        fft_input[i] = 0.0f;
    }

    // Perform FFT
    kiss_fftr(fft_cfg, fft_input, fft_output);

    // Compute power spectrum
    static float power_spectrum[256];
    power_spectrum[0] = fft_output[0].r * fft_output[0].r; // DC
    power_spectrum[fft_bins - 1] = fft_output[fft_bins - 1].r * fft_output[fft_bins - 1].r; // Nyquist
    for (int i = 1; i < fft_bins - 1; i++) {
        power_spectrum[i] = fft_output[i].r * fft_output[i].r +
                            fft_output[i].i * fft_output[i].i;
    }

    // Apply mel filterbank
    for (int i = 0; i < num_mel_bins; i++) {
        float sum = 0.0f;
        for (int j = 0; j < fft_bins; j++) {
            sum += filterbanks[i][j] * power_spectrum[j];
        }
        output[i] = logf(sum + 1e-6f);
    }

    return true;
}
